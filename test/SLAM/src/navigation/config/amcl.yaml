odom_frame_id: odom  #//里程計默認使用的座標系
base_frame_id: base_link  #//用作機器人的基座標系
global_frame_id: map  #//由定位系統發佈的座標系名稱
tf_broadcast: true  #//設置爲false阻止amcl發佈全局座標系和里程計座標系之間的tf變換

max_particles: 5000   #//允許的例子數量的最大值，默認5000
kld_err:       0.05   #//真實分佈和估計分佈之間的最大誤差，默認0.01
kld_z:         0.99   #//上標準分位數（1-p），其中p是估計分佈上誤差小於kld_err的概率，默認0.99
update_min_d:  0.2    #//在執行濾波更新前平移運動的距離，默認0.2m(對於里程計模型有影響，模型中根據運動和地圖求最終位姿的釋然時丟棄了路徑中的相關所有信息，已知的只有最終位姿，爲了規避不合理的穿過障礙物後的非零似然，這個值建議不大於機器人半徑。否則因更新頻率的不同可能產生完全不同的結果)
update_min_a: 0.35          #//執行濾波更新前旋轉的角度，默認pi/6 rad
resample_interval: 2       #//在重採樣前需要的濾波更新的次數,默認2
transform_tolerance: 0.1   #//tf變換髮布推遲的時間，爲了說明tf變換在未來時間內是可用的
recovery_alpha_slow: 0.0   #//慢速的平均權重濾波的指數衰減頻率，用作決定什麼時候通過增加隨機位姿來recover，默認0（disable），可能0.001是一個不錯的值
recovery_alpha_fast: 0.0   #//快速的平均權重濾波的指數衰減頻率，用作決定什麼時候通過增加隨機位姿來recover，默認0（disable），可能0.1是個不錯的值
gui_publish_rate: 2.0     #//掃描和路徑發佈到可視化軟件的最大頻率，設置參數爲-1.0意爲失能此功能，默認-1.0
save_pose_rate: 0.5        #//存儲上一次估計的位姿和協方差到參數服務器的最大速率。被保存的位姿將會用在連續的運動上來初始化濾波器。-1.0失能。
use_map_topic: true       #//當設置爲true時，AMCL將會訂閱map話題，而不是調用服務返回地圖。也就是說，當設置爲true時，有另外一個節點實時的發佈map話題，也就是機器人在實時的進行地圖構建，並供給amcl話題使用；當設置爲false時，通過map server，也就是調用已經構建完成的地圖。在navigation 1.4.2中新加入的參數。
first_map_only: false      #//當設置爲true時，AMCL將僅僅使用訂閱的第一個地圖，而不是每次接收到新的時更新爲一個新的地圖，在navigation 1.4.2中新加入的參數。

    #//激光模型參數
laser_min_range: 0.2 #//被考慮的最小掃描範圍；參數設置爲-1.0時，將會使用激光上報的最小掃描範圍
laser_max_range: 10.0  #//被考慮的最大掃描範圍；參數設置爲-1.0時，將會使用激光上報的最大掃描範圍
laser_max_beams: 30   #//更新濾波器時，每次掃描中多少個等間距的光束被使用（減小計算量，測距掃描中相鄰波束往往不是獨立的可以減小噪聲影響，太小也會造成信息量少定位不準）
#<!--
#這4個laser_z參數，在動態環境下的定位時用於異常值去除技術（還有一種狀態增廣技術-將隱藏狀態包含進狀態估計，缺點是計算複雜，acml定位未使用這種定位）
#這種定位思想是環境中的動態物體總是會獲得比靜態地圖障礙物更短的讀數（人在障礙物後面是掃描不到的-假如不考慮體積，比如單個激光光束不用考慮體積），利用這樣的不對稱性去除異常值
#缺點是：在其他可改變環境的其他類型情景（如去除障礙物）時，這樣的非對稱性可能不存在，但相同概率分析通常是可適用的。因爲每一個異常值都被捨棄了，缺少對稱性的缺點可能是從全局定位失效中恢復變得不可能。這種情況下，×××強加額外約束（如限制部分可能已被破壞的測量值）是有意義的（×××怎麼約束）。（這裏說的捨棄與likelihood_field模型的捨棄有區別，這裏定位是先計算測量值對應非預期物體的概率（意外對象概率/混合概率）大於用戶設定的閥值（amcl配置參數裏貌似沒有這個？）捨棄，而似然域概率是捨棄的超出最大測量範圍的值，不計算概率。）
#（針對這個缺點不想改代碼的粗暴又好用省心的處理方式可能是構圖的時候將可移動的障礙物搬走，還有更直接的辦法就是PS）
#最後，概率由這4個權重乘他們對應的概率然後相加，算法中4個權重相加等於1(這裏默認值不等於1，估計做了歸一化)。
#這6個laser_參數可以用learn_intrinsic_parameters算法計算，該算法是期望值極大化算法，是估計極大似然參數的迭代過程。（×××好吧，amcl好像並沒有做這個工作）
#-->
laser_z_hit: 0.5 #//模型的z_hit部分的混合權值，默認0.95(混合權重1.具有局部測量噪聲的正確範圍--以測量距離近似真實距離爲均值，其後laser_sigma_hit爲標準偏差的高斯分佈的權重)
laser_z_short: 0.05 #//模型的z_short部分的混合權值，默認0.1（混合權重2.意外對象權重（類似於一元指數關於y軸對稱0～測量距離（非最大距離）的部分：--ηλe^(-λz)，其餘部分爲0，其中η爲歸一化參數，λ爲laser_lambda_short,z爲t時刻的一個獨立測量值（一個測距值，測距傳感器一次測量通常產生一系列的測量值）），動態的環境，如人或移動物體）
laser_z_max: 0.05 #//模型的z_max部分的混合權值，默認0.05（混合權重3.測量失敗權重（最大距離時爲1，其餘爲0），如聲吶鏡面反射，激光黑色吸光對象或強光下的測量，最典型的是超出最大距離）
laser_z_rand: 0.5 #//模型的z_rand部分的混合權值，默認0.05（混合權重4.隨機測量權重--均勻分佈（1平均分佈到0～最大測量範圍），完全無法解釋的測量，如聲吶的多次反射，傳感器串擾）
laser_sigma_hit: 0.2 #//被用在模型的z_hit部分的高斯模型的標準差，默認0.2m
laser_lambda_short: 0.1 #//模型z_short部分的指數衰減參數，默認0.1（根據ηλe^(-λz)，λ越大隨距離增大意外對象概率衰減越快）
laser_likelihood_max_dist: 2.0 #//地圖上做障礙物膨脹的最大距離，用作likelihood_field模型（likelihood_field_range_finder_model只描述了最近障礙物的距離，（目前理解應該是在這個距離內的障礙物膨脹處理,但是算法裏又沒有提到膨脹，不明確是什麼意思）.這裏算法用到上面的laser_sigma_hit。似然域計算測量概率的算法是將t時刻的各個測量（捨去達到最大測量範圍的測量值）的概率相乘，單個測量概率：Zh * prob(dist,σ) +avg，Zh爲laser_z_hit,avg爲均勻分佈概率，dist最近障礙物的距離，prob爲0爲中心標準方差爲σ（laser_sigma_hit）的高斯分佈的距離概率）
laser_model_type: likelihood_field   #//模型使用，可以是beam, likehood_field, likehood_field_prob（和likehood_field一樣但是融合了beamskip特徵--官網的註釋），默認是“likehood_field” 

    #//里程計模型參數
    #<!--
    #×××里程計模型並沒有涉及機器人漂移或打滑的情況，一旦出現這樣的情況，後續定位基本廢了，雖然Augmented_MCL有失效恢復，但是實際運行中耗時太長且結果不太理想（位置居然跳，這很不合理，可能參數配置不太好）
    #-->
odom_model_type: diff #//模型使用，可以是"diff", "omni", "diff-corrected", "omni-corrected",後面兩  個是對老版本里程計模型的矯正，相應的里程計參數需要做一定的減小
odom_alpha1: 0.3 #//指定由機器人運動部分的旋轉分量估計的里程計旋轉的期望噪聲，默認0.2（旋轉存在旋轉噪聲）
odom_alpha2: 0.3 #//制定由機器人運動部分的平移分量估計的里程計旋轉的期望噪聲，默認0.2（旋轉中可能出現平移噪聲）
    #<!-- translation std dev, m -->
odom_alpha3: 0.8 #//指定由機器人運動部分的平移分量估計的里程計平移的期望噪聲，默認0.2（類似上）
odom_alpha4: 0.3 #//指定由機器人運動部分的旋轉分量估計的里程計平移的期望噪聲，默認0.2（類似上）
odom_alpha5: 0.1 #//平移相關的噪聲參數（僅用於模型是“omni”的情況--wiki官網的註釋）



    #//機器人初始化數據設置
initial_pose_x: 0.0 #//初始位姿均值（x），用於初始化高斯分佈濾波器。（initial_pose_參數決定撒出去的初始位姿粒子集範圍中心）
initial_pose_y: 0.0 #//初始位姿均值（y），用於初始化高斯分佈濾波器。（同上）
initial_pose_a: 0.0 #//初始位姿均值（yaw），用於初始化高斯分佈濾波器。（粒子朝向）
initial_cov_xx: 0.5*0.5 #//初始位姿協方差（x*x），用於初始化高斯分佈濾波器。（initial_cov_參數決定初始粒子集的範圍）
initial_cov_yy: 0.5*0.5 #//初始位姿協方差（y*y），用於初始化高斯分佈濾波器。（同上）
initial_cov_aa: (π/12)*(π/12) #//初始位姿協方差（yaw*yaw），用於初始化高斯分佈濾波器。（粒子朝向的偏差）許振蕩的秒數


